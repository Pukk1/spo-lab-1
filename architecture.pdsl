architecture spo309681 {

    registers:
        storage SP[16]; /* Стековый указатель */
        storage IP[16]; /* Указатель на текущую инструкцию */
        storage BP[16]; /* Указатель на базовый адрес фрейма стека */
        storage HP[16]; /* Указатель на кучу */
        storage IO_PORT[64]; /* Порт ввода-вывода */

    memory:
        range ram [0x0000..0xFFFF] {
            cell = 8;
            endianess = big-endian;
            granularity = 0;
        }

    instructions:
        encode imm64 field = immediate [64];

        instruction push = { 0000 0000 0000 0001, imm64 as value } {
            SP = SP - 8;
            ram:8[SP] = value;
            IP = IP + 10;
        };

        instruction pop = { 0000 0000 0000 0010 } {
            SP = SP + 8;
            IP = IP + 2;
        };

        instruction load_const = { 0000 0000 0000 0011, imm64 as addr } {
            SP = SP - 8;
            ram:8[SP] = ram:8[addr];
            IP = IP + 10;
        };

        instruction load_bp = { 0000 0000 0000 0100, imm64 as shift } {
            SP = SP - 8;
            ram:8[SP] = ram:8[BP - 8 - shift * 8];
            IP = IP + 10;
        };

        instruction load = { 0000 0000 0000 0101 } {
            let addr = ram:8[SP];
            ram:8[SP] = ram:8[addr];
            IP = IP + 2;
        };

        instruction save_bp = { 0000 0000 0000 0110, imm64 as shift } {
            ram:8[BP - 8 - shift * 8] = ram:8[SP];
            SP = SP + 8;
            IP = IP + 10;
        };

        instruction save = { 0000 0000 0000 0111 } {
            let value = ram:8[SP];
            SP = SP + 8;
            let addr = ram:8[SP];
            ram:8[addr] = value;
            IP = IP + 2;
        };

        instruction add = { 0000 0000 0001 0000 } {
            let a = ram:8[SP];
            SP = SP + 8;
            let b = ram:8[SP];
            let value = a + b;
            ram:8[SP] = value;
            IP = IP + 2;
        };

        instruction sub = { 0000 0000 0010 0000 } {
            let b = ram:8[SP];
            SP = SP + 8;
            let a = ram:8[SP];
            let value = a - b;
            ram:8[SP] = value;
            IP = IP + 2;
        };

        instruction mul = { 0000 0000 0011 0000 } {
            let a = ram:8[SP];
            SP = SP + 8;
            let b = ram:8[SP];
            let value = a * b;
            ram:8[SP] = value;
            IP = IP + 2;
        };

        instruction div = { 0000 0000 0100 0000 } {
            let b = ram:8[SP];
            SP = SP + 8;
            let a = ram:8[SP];
            let value = a / b;
            ram:8[SP] = value;
            IP = IP + 2;
        };

        instruction op_and = { 0000 0000 0101 0000 } {
            let a = ram:8[SP];
            SP = SP + 8;
            let b = ram:8[SP];
            let value = a & b;
            ram:8[SP] = value;
            IP = IP + 2;
        };

        instruction op_or = { 0000 0000 0110 0000 } {
            let a = ram:8[SP];
            SP = SP + 8;
            let b = ram:8[SP];
            let value = a | b;
            ram:8[SP] = value;
            IP = IP + 2;
        };

        instruction lt = { 0000 0000 0111 0000 } {
            let a = ram:8[SP];
            SP = SP + 8;
            let b = ram:8[SP];
            if (a < b) then ram:8[SP] = 1; else ram:8[SP] = 0;
            ram:8[SP] = 0;
            IP = IP + 2;
        };

        instruction lte = { 0000 0000 1000 0000 } {
            let a = ram:8[SP];
            SP = SP + 8;
            let b = ram:8[SP];
            if (a <= b) then ram:8[SP] = 1; else ram:8[SP] = 0;
            ram:8[SP] = 0;
            IP = IP + 2;
        };

        instruction gt = { 0000 0000 1001 0000 } {
            let a = ram:8[SP];
            SP = SP + 8;
            let b = ram:8[SP];
            if (a > b) then ram:8[SP] = 1; else ram:8[SP] = 0;
            ram:8[SP] = 0;
            IP = IP + 2;
        };

        instruction gte = { 0000 0000 1010 0000 } {
            let a = ram:8[SP];
            SP = SP + 8;
            let b = ram:8[SP];
            if (a >= b) then ram:8[SP] = 1; else ram:8[SP] = 0;
            ram:8[SP] = 0;
            IP = IP + 2;
        };

        instruction eq = { 0000 0000 1011 0000 } {
            let a = ram:8[SP];
            SP = SP + 8;
            let b = ram:8[SP];
            if (a == b) then ram:8[SP] = 1; else ram:8[SP] = 0;
            ram:8[SP] = 0;
            IP = IP + 2;
        };

        instruction neq = { 0000 0000 1100 0000 } {
            let a = ram:8[SP];
            SP = SP + 8;
            let b = ram:8[SP];
            if (a != b) then ram:8[SP] = 1; else ram:8[SP] = 0;
            ram:8[SP] = 0;
            IP = IP + 2;
        };

        instruction jz = { 0000 0001 0000 0000, imm64 as addr } {
            if (ram:8[SP] == 0) then IP = addr; else IP = IP + 10;
            SP = SP + 8;
        };

        instruction jnz = { 0000 0010 0000 0000, imm64 as addr } {
            if (ram:8[SP] != 0) then IP = addr; else IP = IP + 10;
            SP = SP + 8;
        };

        instruction jmp = { 0000 0011 0000 0000, imm64 as addr } {
            IP = addr;
        };

        instruction call = { 0001 0000 0000 0000, imm64 as addr } {
            SP = SP - 8;
            BP = SP;
            ram:8[SP] = IP + 10;
            IP = addr;
        };

        instruction ret = { 0010 0000 0000 0000, imm64 as arg_number, imm64 as returned } {
            SP = BP;
            IP = ram:8[SP];
            SP = SP + 8;
            SP = SP + arg_number * 8;
            SP = SP - 8;
            if returned == 1 then {
                ram:8[SP] = ram:8[BP - 8];
            } else {
                ram:8[SP] = 0;
            }
        };

        instruction alloc = { 1110 0000 0000 0000, imm64 as byte_size } {
            SP = SP - 8;
            ram:8[SP] = HP;
            HP = HP + byte_size;
            IP = IP + 10;
        };

        instruction init = { 1111 0000 0000 0000, imm64 as code_end_addr } {
            HP = code_end_addr;
            IP = IP + 10;
        };

        instruction hlt = { 1111 1111 1111 1111 } {};

    mnemonics:
        mnemonic PUSH for push(value) "{1}";
        mnemonic POP for pop();
        mnemonic LOAD_CONST for load_const(addr) "{1}";
        mnemonic LOAD_BP for load_bp(shift) "{1}";
        mnemonic SAVE_BP for save_bp(shift) "{1}";
        mnemonic LOAD for load();
        mnemonic SAVE for save();

        mnemonic ADD for add();
        mnemonic SUB for sub();
        mnemonic MUL for mul();
        mnemonic DIV for div();
        mnemonic BIT_AND for op_and();
        mnemonic OR for op_or();
        mnemonic LT for lt();
        mnemonic LTE for lte();
        mnemonic GT for gt();
        mnemonic GTE for gte();
        mnemonic EQ for eq();
        mnemonic NEQ for neq();

        mnemonic JZ for jz(addr) "{1}";
        mnemonic JNZ for jnz(addr) "{1}";
        mnemonic JMP for jmp(addr) "{1}";

        mnemonic CALL for call(addr) "{1}";
        mnemonic RET for ret(arg_number, returned) "{1},{2}";

        mnemonic ALLOC for alloc(byte_size) "{1}";
        mnemonic INIT for init(code_end_addr) "{1}";
        mnemonic HLT for hlt();
}
